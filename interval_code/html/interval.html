<html><head><title>interval Documentation</title></head>
<body><h1>
<a name="topofdoc"><img src="diag2min.gif">interval</a></h1>
<dl>
<dd>
	A class representing real-valued intervals


</dl>
<hr><p></p>
<p><strong>[ 
<a href="kepler.html">kepler</a> | 
<a href="interval.h">Source</a> | 
<a href="keyweb.html">Keywords</a> | 
<a href="#aag">Summary</a> | <a href="#parents">Ancestors</a> | <a href="#flat">All Members</a> | <a href="#children">Descendants</a>  ]</strong><p>
<h2><a name="quickind">Quick Index</a></h2>
<dl>
<dd><a href="#OVERVIEW_TEXT">OVERVIEW TEXT</a>
<dd><a href="#AUTHOR">AUTHOR</a>
</dl>
<a name="aag"><hr><p></p></a><h2>Class Summary</h2>
class interval<br>
<br>
 {
<br>
<br><i><b>public</b></i>:
<dl>
<dd><a href="interval.html#interval(const_char_*)$">interval</a>(const char *);
<dd><strong>static</strong> interval <a href="interval.html#interval_wideInterval(const_char_*,const_char_*)$">wideInterval</a>(const char *,const char *);
<dd><a href="interval.html#interval(double,double)$">interval</a>(double,double);
<dd><a href="interval.html#interval()_$">interval</a>() ;
<dd>interval <a href="interval.html#interval_operator+(interval)_const$">operator+</a>(interval) const;
<dd>interval <a href="interval.html#interval_operator-(interval)_const$">operator-</a>(interval) const;
<dd>interval <a href="interval.html#interval_operator*(interval)_const$">operator*</a>(interval) const;
<dd>interval <a href="interval.html#interval_operator$(interval)_const$">operator/</a>(interval) const;
<dd>interval <a href="interval.html#interval_operator-()_const$">operator-</a>() const;
<dd>int <a href="interval.html#int_operator&lt(interval)_const$">operator&lt</a>(interval) const;
<dd>int <a href="interval.html#int_operator&gt(interval)_const$">operator&gt</a>(interval) const;
<dd>int <a href="interval.html#int_operator$$(interval)_const$">operator==</a>(interval) const;
</dl>
<i><b>protected</b></i>:
<dl>
</dl>
}; // interval <p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>interval</i><p>
<a name="OVERVIEW_TEXT"><hr><p></p></a><h3>OVERVIEW TEXT</h3>
	An interval is the the most important data structure in the kepler package.
	It represents a real-valued interval whose endpoints are exactly 
	representable by computer.   Basic arithmetic operations *,+,/,- are
	overloaded to give correctly rounded interval arithmetic. 
<p>
	Additional procedures for manipulating intervals are found in the
	<a href="interMath.html">interMath</a> class.
<p>
	An <a href="http://cs.utep.edu/interval-comp/main.html">
	introduction</a> to interval arithmetic
<p>
	It is unworthy of excellent persons to lose hours like slaves in the labor
	of calculation.
<p>
	. . . Gottfried Wilhelm von Leibniz 
<p>
	Back to the 
	<a href="../index.html">Kepler</a>
	conjecture home page.
<p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>interval</i><p>
<a name="AUTHOR"><hr><p></p></a><h3>AUTHOR</h3>
	Thomas C. Hales
<p>Back to the <a href="#topofdoc">top</a> of  <i>interval</i><p>
<a name="interval(const_char_*)$"><hr><p></p><h3>interval(const char *);</h3></a>
		   A standard constructor for intervals.
		   Intervals are general initialized by strings rather than
		   as decimal constants.  The rounding mode is set appropriately
		   when the string is converted to an interval, so that an interval
		   bracketing the decimal conversion of the string is obtained.
<p>
		   We use strings because of untrustworthy things that compilers
		   do with doubles.  For example, on my Sun CC and SGI CC compilers
		   even if the rounding mode is set upward <a href="interMath.html">interMath</a>::up(), we get
		   assert(1.0 == 1.0+DBL_MIN) even though DBL_MIN is positive.
		   Similarly, although claiming to be IEEE compliant, programs give
		   assert(1.0 == 1.00000000000000000001) even when the rounding
		   mode is directed upward.  It seems that constants are computed
		   at compile time, but rounding modes are set at run time, so
		   to get a reliable constant, we must wrap constants in a string until
		   run time.
<p>
<p><pre>
	<a href="#interval()_$">interval</a>(const char *); // construct with a string; <a href="#interval()_$">interval</a>("3.14"), etc.
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="interval_wideInterval(const_char_*,const_char_*)$"><hr><p></p><h3>interval wideInterval(const char *,const char *);</h3></a>
		   Another constructor for intervals
		   The first string is converted using downward rounding to the
		   lower bound of the interval.  The second string is rounding
		   up to a representable number giving the upper bound of the interval.
<p>
<p><pre>
	static interval <a href="#interval_wideInterval(const_char_*,const_char_*)$">wideInterval</a>(const char *,const char *); // lo, hi
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="interval(double,double)$"><hr><p></p><h3>interval(double,double);</h3></a>
		   Construct an interval from the endpoints.  Refer to the comments
		   for the string constructor to see the shortfalls of a double
		   type constructor.  This constructor should only be used on
		   doubles that are computed at run time using interval
		   arithmetic.
<p>
<p><pre>
	inline <a href="#interval()_$">interval</a>(double,double); // lo, hi
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="interval()_$"><hr><p></p><h3>interval() ;</h3></a>
		   This constructor does nothing
<p>
<p><pre>
	<a href="#interval()_$">interval</a>()   ;
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="interval_operator+(interval)_const$"><hr><p></p><h3>interval operator+(interval) const;</h3></a>
		   Addition of intervals is based on IEEE rounding modes so that
		   the interval returned contains the sum of the two intervals.
<p>
<p><pre>
	inline interval operator+(interval) const;
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="interval_operator-(interval)_const$"><hr><p></p><h3>interval operator-(interval) const;</h3></a>
		   Subtraction of intervals is based on IEEE rounding modes so that
		   the interval returned contains the difference of the two intervals.
<p>
<p><pre>
	inline interval operator-(interval) const;
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="interval_operator*(interval)_const$"><hr><p></p><h3>interval operator*(interval) const;</h3></a>
		   Multiplication of intervals is based on IEEE rounding modes so that
		   the interval returned contains the product of the two intervals.
		   Multiplication is performed inline if both intervals are
		   completely positive.  Otherwise, a long procedure with many
		   cases is called
<p>
<p><pre>
	inline interval operator*(interval) const;
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="interval_operator$(interval)_const$"><hr><p></p><h3>interval operator/(interval) const;</h3></a>
		   Division of intervals is based on IEEE rounding modes.  In the
		   current implementation x/y is computed as x times the reciprocal
		   of y.  If the interval y contains zero, an <a href="error.html">error</a> message is
		   issued and zero is returned.
		   An extremely paranoid view is taken of division by zero.  If
		   the interval comes within float.h's DBL_EPSILON of zero, then
		   it is considered an <a href="error.html">error</a>.  The user might want to change
		   the constant to something less paranoid, such as DBL_MIN.
<p>
<p><pre>
	inline interval operator/(interval) const;
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="interval_operator-()_const$"><hr><p></p><h3>interval operator-() const;</h3></a>
		   Unary negation of intervals.  This operation should be independent
		   of the rounding mode.
<p>
<p><pre>
	inline interval operator-() const;
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="int_operator&lt(interval)_const$"><hr><p></p><h3>int operator&lt(interval) const;</h3></a>
		   Is completely less than.  This relation is true only if
		   every element of the first interval is strictly less than
		   every element of the second.
<p>
<p><pre>
	inline int operator&lt(interval) const; // completely less than 
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="int_operator&gt(interval)_const$"><hr><p></p><h3>int operator&gt(interval) const;</h3></a>
		   Is completely greater than.  This relation is true only if
		   every element of the first interval is strictly greater than
		   every element fo the second.
<p>
<p><pre>
	inline int operator&gt(interval) const; // completely greater than
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="int_operator$$(interval)_const$"><hr><p></p><h3>int operator==(interval) const;</h3></a>
		    Is identically equal to.  This relation between intervals
		    is true if both endpoints are equal.
<p>
<p><pre>
	inline int operator==(interval) const;  // identically =
</pre>
<p><em>Function is currently defined <strong>inline</strong>.</em></p>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> interval </i> <p>
<a name="flat"><hr><p></p></a>
<h2>All Members</h2>
<dl>
<dt><strong>public:</strong>
<dd><strong>static</strong> interval <a href="interval.html#interval_wideInterval(const_char_*,const_char_*)$">wideInterval</a>(const char *,const char *);
<dd>interval <a href="interval.html#interval_operator+(interval)_const$">operator+</a>(interval) const;
<dd>interval <a href="interval.html#interval_operator-(interval)_const$">operator-</a>(interval) const;
<dd>interval <a href="interval.html#interval_operator*(interval)_const$">operator*</a>(interval) const;
<dd>interval <a href="interval.html#interval_operator$(interval)_const$">operator/</a>(interval) const;
<dd>interval <a href="interval.html#interval_operator-()_const$">operator-</a>() const;
<dd>int <a href="interval.html#int_operator&lt(interval)_const$">operator&lt</a>(interval) const;
<dd>int <a href="interval.html#int_operator&gt(interval)_const$">operator&gt</a>(interval) const;
<dd>int <a href="interval.html#int_operator$$(interval)_const$">operator==</a>(interval) const;
<dt><strong>protected:</strong>
</dl>
<p>Back to the <a href="#topofdoc">top</a> of  interval<p>
<a name="parents"><hr><p></p></a>
<h2>Ancestors</h2>
Class does not inherit from any other class.<p>
<p>Back to the <a href="#topofdoc">top</a> of  interval<p>
<a name="children"><hr><p></p></a>
<h2>Descendants</h2>
Class is not inherited by any others.<p>
<p>Back to the <a href="#topofdoc">top</a> of  interval<p>
<hr><p></p>
Generated from source by the <i><a href="http://www.cs.umn.edu/~kotula/cocoon/cocoon.htm">Cocoon</a></i> utilities on Mon Dec 22 19:37:20 1997
.<p>
<address>Report <a href="mailto:jkotula@unimax.com">problems</a> to jkotula@unimax.com</address>
</body></html>
