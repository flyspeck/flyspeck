(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: Hypermap, Tame Hypermap                                           *)
(* Author:  Thomas Hales     *)
(* Date: 2011-04-29 -- 2014-08                                                *)
(* ========================================================================== *)

(* Port The Bauer-Nipkow completeness theorem from Isabelle,
    based on
   http://afp.sourceforge.net/devel-entries/Flyspeck-Tame.shtml
   http://afp.sourceforge.net/browser_info/current/HOL/Flyspeck-Tame/outline.pdf

   This is a translation of the Isabelle results.  

   The tame_classification_theorem is the translation into HOL
   Light of the main result of Flyspeck I, Bauer-Nipkow.  

   The definitions here are the same as those in
   the module Import_tame_classification, with extra annotations
   for the corresponding definitions in Isabelle.
*)


(*
To check compatibility.
1. run diff on Tri.ML, Quad.ML, Pent.ML, Hex.ML to compare graphs.


*)

needs "Library/rstc.ml";; (* for RTC reflexive transitive closure *)
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
(* flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";; *)

(*
flyspeck_needs "../tame_archive/tame_archive.hl";;
*)

module Isabelle_hollight_translation = struct

  open Hales_tactic;;
  open Tame_defs;;
  open Tame_list;;
  open Tame_defs2;;


  let overrides,add_override = 
    let os = ref [] in
    let ao t = (os := t :: !os) in
    let oo() = map override_interface (!os) in
      (oo,ao);;
  
  let override_interface' (a,b) = 
    let _ = report ("override " ^ a ^ " " ^(string_of_term b)) in
    let _ = add_override (a,b) in
      override_interface (a,b);;

  let makeovers,add_makeover = 
    let os = ref [] in
    let ao t = (os := t :: !os) in
    let oo() = map (fun (a,b) -> make_overloadable a b) (!os) in
      (oo,ao);;
  
  let make_overloadable' a b = 
    let _ = report ("makeover " ^ a ^ " " ^(string_of_type b)) in
    let _ = add_makeover (a,b) in
      make_overloadable a b;;

  let overloads,add_overload = 
    let os = ref [] in
    let ao t = (os := t :: !os) in
    let oo() = map overload_interface (!os) in
      (oo,ao);;
  
  let overload_interface' (a,b) = 
    let _ = report ("overload " ^ a ^ " " ^(string_of_term b)) in
    let _ = add_overload (a,b) in
      overload_interface (a,b);;

  let parse_as_infixes,add_parse_as_infix =
    let pais = ref [] in
    let apai t = (pais := t :: !pais) in
    let pai () = map parse_as_infix (!pais) in
      (pai,apai);;

  let parse_as_infix' t = 
    let _ = add_parse_as_infix t in
      parse_as_infix t;;

  let notation() = 
    let _ = parse_as_infixes() in
    let _ = overrides() in
    let _ = makeovers() in
    let _ = overloads() in
      ();;

parse_as_infix' ("::", (12, "right"));;
override_interface' ("::", `CONS`);;
parse_as_infix' ("^^", (24, "right"));;
override_interface' ("^^", `POWER`);;
parse_as_infix' ("~=", (12, "right"));;

  let ISADIR = 
    let dir = (Sys.getenv "FLYSPECK_DIR") in
     Filename.concat dir "../formal_graph";;

  let HOLDIR = Filename.concat ISADIR "isabelle_hol";;
  let TAMEDIR = Filename.concat ISADIR "isabelle_tame";;

  let TESTDIR = "~/Desktop";;

  let tamefile  = Filename.concat TAMEDIR;;
  let holfile = Filename.concat HOLDIR;;
  let testfile = Filename.concat TESTDIR;;


(* ************************************************************************** *)
(* TYPES *)
(* ************************************************************************** *)



(*
types: num, (A) list, (A ==> B), (A) Option, A#B, bool.
(* type (a,b) table is (a#b) list *)
*)


  type liz_ty = {
    liz_ty_loc : (string*int*int);
    liz_t : string;
    liz_h : string;
  };;

  let lizt = ref [];;

  let liz_ty recd = 
    let _ = lizt := (recd::!lizt) in ();;

  liz_ty {
    liz_ty_loc = ("",0,0);
    liz_t = "vertex";
    liz_h = "num";
  };;

  liz_ty {
    liz_ty_loc = ("",0,0);
    liz_t = "facetype";
    liz_h = "bool";
  };;

  liz_ty {
    liz_ty_loc = ("",0,0);
    liz_t = "face";
    liz_h = "(num list)#bool";
  };;

(*  datatype graph = Graph "(face list)" "nat" "face list list" "nat list" *)

  liz_ty {
    liz_ty_loc = (tamefile "Graph.thy",117,117);
    liz_t = "graph";
    liz_h = "((num list#bool) list) # num # (((num list#bool) list) list) # num list";
  };;

  liz_ty {
    liz_ty_loc = (tamefile "Vector.thy",10,10);
    liz_t = "vector";
    liz_h = "list";
  };;

(*
type_synonym 'a Fgraph = "'a list set"
type_synonym 'a fgraph = "'a list list"
*)

  liz_ty {
    liz_ty_loc = (tamefile "PlaneGraphIso.thy",43,43);
    liz_t = "(A) Fgraph";
    liz_h = "(A) list -> bool";
  };;

  liz_ty {
    liz_ty_loc = (tamefile "PlaneGraphIso.thy",44,44);
    liz_t = "(A) fgraph";
    liz_h = "((A) list) list";
  };;

(* ************************************************************************** *)
(* TERMS *)
(* ************************************************************************** *)

(* expand syntactic sugar *)

  let get_liz_def = 
    let p = Printf.sprintf in
    let tok = "[a-zA-Z0-9_]*" in
    let words = "[a-zA-Z0-9_ ]*" in
    let wordp = "[a-zA-Z0-9_)@^(=.\\ ]*" in
    let escape_quote = "'s/\"/ \\\" /g'" in
    let expand_angle1 = p "'s/\\\\<^\(%s\)>/ ___\1 /g'" tok in
    let expand_angle2 = p "'s/\\\<\([%s\)>/ __\1 /g'" tok in
    let expand_let = p "'s/ let *\([^;]*\) *; *\(.*\) in / let \1 in let \2 in /g'" in
    let expand_comment = p "'s/(\*[^*]*\*)//g'" in
      (* expand_Squnion : ListAux.thy 120,123 *)
    let expand_Squnion = p "'s/__Squnion *___bsub *\(%s\)  *__in  *\(.*\) *___esub *\([^()\"]*\)/(concat (map(\\\\ \1 . \3 )  (\2) ))/g'" tok in
    let expand_upt = p "'s/\[ *\(%s\) *\.\.< *\([^]]*\) *\]/(upt (\1) (\2))/g'" words  in
    let expand_map = p "'s/\[\([^.]*\)\. *\(%s\) *<- *\(%s\)\]/(map (\\\\ \2 . \1) (\3))/g'" tok words in
    let expand_map2 = p "'s/\[\([^.]*\)\. *\(%s\) *__leftarrow *\(%s\)\]/(map (\\\\ \2 . \1) (\3))/g'" tok wordp in
    let expand_filter = p "'s/\[\([^.]*\) *__leftarrow *\([^.]*\) *\. *\(%s\)\]/(filter (\\\\ \1 . \3) (\2))/g'" wordp in
      (* expand_update : List.thy 118,126 *)
    let expand_update = p "'s/\(%s\) *\[\(%s\) *:= *\([^]]*\)\]/(list_update (\1) (\2) (\3))/g'" tok tok in
    let expand_length = p "'s/| *\(%s\) *|/(length \1)/g'" tok in
    let expand_length2 = p "'s/|\(%s\)|/(length (\1))/g'" wordp in
    let expand_isub = p "'s/ *___isub *//g'" in
    let expand_forall_in = p "'s/__forall *\(%s\) *__in *\([^.]*\) *\./__forall \1 . (\1 __in \2) __longrightarrow/g'" tok in
    let expand_nextV = p "'s/\(%s\) *___bsup *\(%s\) *___esup *__bullet *\(%s\)/nextVertices \1 \2 \3/g'" tok tok tok in
    let expand_label1 = p "'s/where *[a-zA-Z0-9_]*:/where /g'" in
    let expand_label2 = p "'s/| *[a-zA-Z0-9_]*:/| /g'" in
    let case_num = p "'s!case *\(%s\) *of *0 *__Rightarrow * \([^|]*\) *| *Suc *\(%s\) *__Rightarrow *\([a-zA-Z0-9!#_ ]*\)!(if (\1 = 0) then (\2) else (let \3 = PRE (\1) in (\4)))!g'" tok tok in
    let case_facetype = p "'s!case *\(%s\) *of *Final *__Rightarrow * \([^|]*\) *| *Nonfinal *__Rightarrow *\([a-zA-Z0-9!#_ ]*\)!(if (\1 = Final) then (\2) else (\3))!g'" tok in
    let case_list = p "'s!case *\(%s\) *of *\[\] *__Rightarrow * \([^|]*\) *| *( *\(%s\) *# *\(%s\) *) *__Rightarrow *\([a-zA-Z0-9!#<_ ]*\)!(if (\1 = []) then (\2) else (let \3 = HD (\1) in (let \4 = TL (\1) in \5)))!g'" tok tok tok in
    let case_vector = p "'s!case *\(%s\) *of *(Vector \(%s\)) *__Rightarrow * \([^\"]*\) !(let \2 = \1 in (\3))!g'" tok tok in
    let case_option = p "'s!case *\(%s\) *of *None *__Rightarrow *\([^|]*\) *| *(Some \(%s\)) *__Rightarrow *\([a-zA-Z0-9_+=,() ]*\)!(if (\1 = None) then (\2) else (let \3 = the (\1) in (\4)))!g'" tok tok in
      (* Vector.thy 40 "\<lbrakk>f. x < m, y < n\<rbrakk>" == "CONST tabulate2 m n (\<lambda>x y. f)" *)
    let expand_tab = p "'s/__lbrakk *\([^.]*\) *\. *\(%s\) *< *\(%s\) *, *\(%s\) *< *\(%s\) *__rbrakk/ tabulate2 (\3) (\5) (\\\\ \2 \4 . \1) /g'" tok words tok words in
    let expand_RT = p "'s/\(%s\) *\[\(%s\)\] *__rightarrow *\* *\(%s\)/ ((\1),\3) __in RTranCl (\2) /g'" words words tok in (* was t w t *)
    let expand_in_set = p "'s/\(%s\) *\[\(%s\)\] *__rightarrow *\(%s\)/ (\3) __in set_of_list((\2) \1) /g'" tok tok tok in 
    let expand_set = p "'s/{\([^.}]*\)\.\([^}]*\)}/{\1 | \2}/g'" in
    let expand_sum2 = p "'s/ __Sum *___bsub *\(%s\)  *__in  *\(%s\) *___esub *\(%s(%s)\)/listsum (map (\\\\ \1 . \3) (\2)) /g'" tok wordp words words in
    let expand_sum = p "'s/ __Sum *___bsub *\(%s\)  *__in  *\(%s\) *___esub *\(%s\)/listsum (map (\\\\ \1 . \3) (\2)) /g'" tok wordp words in
    let expand_union = p "'s/ __Union *\(%s\)  *__in  *\(%s\) *\. *\(%s\)/UNIONS (IMAGE (\\\\ \1 . \3) (\2)) /g'" tok tok words in
    let expand_sub = p "'s/ ___bsub *\(%s\) *___esub/ \1 /g'" tok in
    let expand_cong = p "'s!//{ *__cong *}! //// (__cong) !g'" in
    let expand_pattern = p "'s!|! /\\\\ !g'" in
(*     let expand_quote = p "'s/\"/ /g'" in *)
    let e = String.concat " -e "
      [escape_quote;expand_angle1;expand_angle2;
       expand_let;expand_let;       expand_let;expand_let;       expand_let;expand_let;       
       expand_let;expand_let;       expand_let;expand_let;       expand_let;expand_let;       
       expand_comment;
       expand_Squnion;expand_length2;expand_upt;expand_map;expand_map2;expand_filter;expand_update;
       expand_length;expand_length2;expand_isub;expand_forall_in;expand_nextV;
       expand_label1;expand_label2;case_num;case_facetype;case_list;case_vector;case_option;
       expand_tab;expand_RT;expand_in_set;expand_set;expand_sum2;expand_sum;
       expand_union;expand_sub;expand_cong;expand_pattern] in 

      fun file lines expand ->
	if (file="") then "" else
	  let e2 = String.concat " -e " [escape_quote] in
	  let sed = p "sed -n %d,%dp %s | tr '\t\n\\047' '  _' | sed -e %s " (fst lines) (snd lines) file e in
	  let sed2 = p "sed -n %d,%dp %s | tr '\t\n\\047' '  _' | sed -e %s " (fst lines) (snd lines) file e2 in
	  let sed'  = if expand then sed else sed2 in
	    if Sys.file_exists file then (process_to_string sed') 
	    else ("def-file not found "^file);;

  let get_hol_def fil lines = 
    let file = Filename.concat HOLDIR fil in
      get_liz_def file lines true;;

  let get_tame_def fil lines = 
    let file = Filename.concat TAMEDIR fil in
      get_liz_def file lines true;;

  let report_def dir files name after = 
    let searchdir = Filename.concat dir files in
    let sp = Printf.sprintf in
    let grep = sp "grep -h -A%d -n '\(primrec\|definition\|abbreviation\|defs .overloaded.\)[ \"]*%s' %s" in
    let out = process_to_string(grep after name searchdir) in
      report(out);;

  let report_tame_def = report_def TAMEDIR "*";;

  let report_list_def = report_def HOLDIR "List.thy";;

  type liz_record = {
    liz_loc : (string*int*int);
    liz_name : string;
    liz_holl : term;
    liz_thm : thm;
  };;

  let print_liz t = 
    let (loc,a,b) = t.liz_loc in
      if (loc = "") then report ("NOT FOUND") else
	report (get_liz_def loc (a,b) true);;

  let lizl = ref [];;

(* Example: *)
report_tame_def "replace" 4;;
report (get_tame_def "ListAux.thy" (167,170));;

  let translate_precedence_to_holl n = if n < 66 then n / 4 else 16 + (n - 66);;

  let get_infixr   =
    let reg = Str.regexp ".*infixr* *\" *\([^\"]*\)\" *\([0-9]*\).*where.*" in
      fun s ->
	let b = Str.string_match reg s 0 in
	  if not(b) then ("",0) else
	    let sy = Str.matched_group 1 s in
	    let p0 =  (Str.matched_group 2 s) in
	    let p = try int_of_string p0 with _ -> failwith p0 in
	      (sy,p);;

  let get_infixl   =
    let reg = Str.regexp ".*infixl *\" *\([^\"]*\)\" *\([0-9]*\).*where.*" in
      fun s ->
	let b = Str.string_match reg s 0 in
	  if not(b) then ("",0) else
	    let sy = Str.matched_group 1 s in
	    let p0 =  (Str.matched_group 2 s) in
	    let p = try int_of_string p0 with _ -> failwith p0 in
	      (sy,p);;

  let get_interface = 
    let reg = Str.regexp ".*:: *\"[^\"]*\" *( *\" *\([A-Za-z0-9_]*\) *\" *) *where.*" in
      fun s ->
	let b = Str.string_match reg s 0 in
	  if not(b) then ("") else
	    let sy = Str.matched_group 1 s in
	      sy;;

  let get_name = 
    let reg1 = Str.regexp "\([A-Za-z0-9_]*\) *::" in
    let reg2 = Str.regexp "primrec *\([A-Za-z0-9_]*\) *where" in
    let reg3 = Str.regexp "defs *([A-Za-z]) *\([A-Za-z0-9_]*\) *:" in
    let get reg s = 
      let _ = Str.search_forward reg s 0 in
	    Str.matched_group 1 s in
      fun s ->
	try get reg1 s
	with Not_found -> 
	  try get reg2 s
	  with Not_found ->
	    try get reg3 s
	    with Not_found -> "";;

  let basic_dictionary = 
    [
    ("[]","[]");
    ("Suc","SUC");
    ("__in","IN");
    ("@","#@#");
    ("#","::");
    ("!","#!#");
    ("`","#?#");
    ];;

  let infixr (s, p) = 
    if (s,p) = ("",0) then "" else
      let s' = String.trim s in
      let ix = assocd s' basic_dictionary s' in
      let _ = report ("adding infixr "^ix) in
      let _ = parse_as_infix' (ix, (translate_precedence_to_holl p,"right")) in
	ix;;

  let infixl (s, p) = 
    if (s,p) = ("",0) then "" else
      let s' = String.trim s in
      let ix = assocd s' basic_dictionary s' in
      let _ = report ("adding infixl "^ix) in
      let _ = parse_as_infix' (ix, (translate_precedence_to_holl p,"left")) in
	ix;;

  let liz_add recd = 
    let _ = lizl := (recd:: !lizl) in
    let (loc,a,b) = recd.liz_loc in
    let s = get_liz_def loc (a,b) true in
    let ixr = infixr (get_infixr s) in
    let _ = (ixr="") or (override_interface'(ixr,recd.liz_holl); true) in
    let ixl = infixl (get_infixl s) in
    let _ = (ixl="") or (override_interface'(ixl,recd.liz_holl); true) in
    let ix = get_interface s in
    let _ = (ix="") or (override_interface'(ix,recd.liz_holl); true) in
    let _ = print_liz recd in
    let nm = get_name s in
    let _ = nm = recd.liz_name or (report ("liz_add name mismatch "^nm); true) in
      recd.liz_thm;;

  let get_liz s = 
    let u = filter (fun recd -> recd.liz_name = s) !lizl in
    let recd = hd u in
    let _ = print_liz recd in
      recd.liz_thm;;


(*
  let infix_table =
    [
    (* List.thy *) ("#","#",'r',65,`CONS`);
      ("append","@",'r',65);
      ("nth","!",'l',100);
      (* Nat.thy *)
      ("funpow","^^",'r',80); 
      (* PlaneGraphIso.thy *)
      ("congs","\<cong>",'x',60); (* no direction 'l' 'r' assigned. Overloaded. *)
    ];;

*)

(*  infixes: =~ (congs) is congruence modulo rotation on lists,  -~ unused on lists.
                  =~ is pr_isomorphism on graphs, -~ isomorphic of graphs.

     {=~} is Isabelle notation for {(f1,f2). f1 =~ f2}.

    type a Fgraph  a list -> bool
            a fgraph a list list
*)
(* overload append -> #@# *)

liz_add {
liz_name = "append";
liz_loc =  (holfile "List.thy",51,53);
liz_holl = `APPEND`;
liz_thm = APPEND;
};;


(*
let case = new_definition' `case (n:A) (a1, b1:B) (a2,b2) = 
  if (n=a1) then b1 else if (n=a2) then b2 else b2`;;
*)



liz_add {
liz_name = "not_equal";
liz_loc =  (holfile "HOL.thy",86,90);
liz_holl = `( ~= ):A->A -> bool`;
liz_thm = not_equal;
};;

liz_add {
liz_name = "nth";
liz_loc =  (holfile "List.thy",106,107);
liz_holl = `(#!#):A list -> num -> A`;
liz_thm = C_EL_REC;
};;

(* XX use a lemma to justify length. 
  In Isabelle, length is an overload of `size` in context of lists.
  such as length_append in List.thy *)

liz_add {
liz_name = "length";
liz_loc =  (holfile "List.thy",189,190); (* see note on lines 185--187, size is overloaded for all datatypes. *)
liz_holl = `(LENGTH:A list -> num)`;
liz_thm = LENGTH;
};;

liz_add {
liz_name = "rev";
liz_loc =  (holfile "List.thy",55,57); 
liz_holl = `REVERSE:A list -> A list`;
liz_thm = REVERSE;
};;


(* List operations in Isabelle-Main:
   op @, concat, filter, length, map, op !, remove1, rev, 
   rotate, rotate1, upto, upt, zip.

   Other things in main:
   the,
   See http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2013/doc/main.pdf
*)

(*
(* HOL Light definition from hypermap. Use ITER instead. *)

parse_as_infix'("POWER",(24,"right"));;

let POWER = new_recursive_definition num_RECURSION 
  `(!(f:A->A). f POWER 0  = I) /\  
   (!(f:A->A) (n:num). f POWER (SUC n) = (f POWER n) o f)`;;
*)


(* import of 1.1 HOL *)
(* 1.2 length xs, 1.2.2 filter P xs, 1.2.3 concat,  *)

(* !! This is an incomplete specification. 
   the (NONE) is not specified and cannot be compared from one
   system to the other *)

liz_add {
liz_name = "the";
liz_loc =  (holfile "Option.thy",44,45); 
liz_holl = `the`;
liz_thm = the_some;
};;

liz_add {
liz_name = "filter";
liz_loc =  (holfile "List.thy",59,62); 
liz_holl = `filter`;
liz_thm = filter_rec;
};;

liz_add {
liz_name = "concat";
liz_loc =  (holfile "List.thy",87,90); 
liz_holl = `flatten`;
liz_thm = concat_flatten;
};;

(*
let concat = new_recursive_definition list_RECURSION
  `concat ([]:(A list)list) = [] /\
    concat ( (x:A list) :: xs) = APPEND x (concat xs)`;;
*)

(* notation: disjoint_sum { x in xs } f  = flatten (MAP (\x. f) xs) *)

(* list_update *)

(* 1.2.3 listProd1, listProd *)

liz_add {
liz_name = "map";
liz_loc =  (holfile "List.thy",47,50); 
liz_holl = `MAP`;
liz_thm = MAP;
};;


liz_add {
liz_name = "listProd1";
liz_loc =  (tamefile "ListAux.thy",127,129); 
liz_holl = `list_prod1`;
liz_thm = list_prod1;
};;

liz_add {
liz_name = "listProd";
liz_loc =  (tamefile "ListAux.thy",130,132); 
liz_holl = `list_prod`;
liz_thm = list_prod;
};;

(* 1.2.5 *)

let minimal_el_alt = prove_by_refinement(
  `!xs m x. minimal_el m (x :: xs) = 
    (if (xs = []) then x else
      (let mxs = minimal_el m xs in
	 (if m x <= m mxs then x else mxs)))`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[minimal_el]);
  ]);;
  (* }}} *)

(* !! incompletely specified *)

liz_add {
liz_name = "minimal";
liz_loc = (tamefile "ListAux.thy",139,143); 
liz_holl = `minimal_el`;
liz_thm = minimal_el_alt;
};;

(* !! incompletely specified *)

liz_add {
liz_name = "min_list";
liz_loc =  (tamefile "ListAux.thy",149,151); 
liz_holl = `min_list`;
liz_thm = min_list_cons;
};;

(* 1.2.6 replace *)


liz_add {
liz_name = "replace";
liz_loc =  (tamefile "ListAux.thy",167,171); 
liz_holl = `replace`;
liz_thm = replace;
};;

liz_add {
liz_name = "list_update";
liz_loc =  (holfile "List.thy",111,115); 
liz_holl = `list_update`;
liz_thm = list_update_ALT;
};;

liz_add {
liz_name = "mapAt";
liz_loc =  (tamefile "ListAux.thy",172,177); 
liz_holl = `mapAt`;
liz_thm = mapAt_ALT;
};;

(* 1.2.9 rotate *)

(* `rot` is different because rot changes only up to the length of the list *)

liz_add {
liz_name = "funpow";
liz_loc =  (holfile "Nat.thy",1264,1266); 
liz_holl = `ITER`;
liz_thm = ITER_o;
};;

liz_add {
liz_name = "rotate1";
liz_loc =  (holfile "List.thy",211,213); 
liz_holl = `rotate1`;
liz_thm = rotate1;
};;

liz_add {
liz_name = "rotate";
liz_loc =  (holfile "List.thy",215,216); 
liz_holl = `rotate`;
liz_thm = REWRITE_RULE[GSYM POWER_TO_ITER] rotate;
};;

(* 1.3 splitAt *)

liz_add {
liz_name = "splitAtRec";
liz_loc =  (tamefile "ListAux.thy",547,551); 
liz_holl = `split_at_rec`;
liz_thm = split_at_rec;
};;

liz_add {
liz_name = "splitAt";
liz_loc =  (tamefile "ListAux.thy",552,554); 
liz_holl = `split_at`;
liz_thm = split_at;
};;

(* 1.4 between *)

unparse_as_infix "INSERT";;

liz_add {
liz_name = "insert";
liz_loc =  ("",0,0);  (* XX *)
liz_holl = `INSERT`;
liz_thm = INSERT_alt;
};;

liz_add {
liz_name = "set";
liz_loc =  (holfile "List.thy",40,43); 
liz_holl = `set_of_list`;
liz_thm = set_of_list;
};;

liz_add {
liz_name = "between";
liz_loc =  (tamefile "ListAux.thy",985,991); 
liz_holl = `betwn`;
liz_thm = betwn;
};;

(* 1.5 Tables *)

(* XX overloaded and infix *)

parse_as_infix' ("__cong", (60, "right"));;

liz_add {  
liz_name = "__cong";
liz_loc =  (tamefile "PlaneGraphIso.thy",50,52); 
liz_holl = `__cong`;
liz_thm = cong;
};;

(* 2.2 homomorphism and isomorphism *)

liz_add {
liz_name = "inj_on";
liz_loc =  (holfile "Fun.thy",122,123); 
liz_holl = `inj_on`;
liz_thm = inj_on_ALT;
};;

(* 3.0 More rotation *)

(*
removed March 9, 2014.
liz_add {
liz_name = "rotate_to";
liz_loc =  (tamefile "Rotation.thy",10,12); 
liz_holl = `rotate_to`;
liz_thm = rotate_to;
};;

liz_add {
liz_name = "rotate_min";
liz_loc =  (tamefile "Rotation.thy",13,15); 
liz_holl = `rotate_min`;
liz_thm = rotate_min;
};;
*)

(* 4.0 Graph,   4.2 Faces  *)

(* XX. This is a datatype in Isabelle:Graph.thy 
   datatype facetype = Final | Nonfinal *)
liz_add {
liz_name = "Final";
liz_loc =  ("",0,0);
liz_holl = `T`;
liz_thm = TRUTH;
};;

(* XX *)
liz_add {
liz_name = "Nonfinal";
liz_loc =  ("",0,0);
liz_holl = `F`;
liz_thm = TRUTH;
};;

(* XX datatype in Isabelle:Graphy.thy *)
liz_add {
liz_name = "Face";
liz_loc =  ("",0,0);
liz_holl = `Face`;
liz_thm = FACE;
};;

make_overloadable' "final" `:A -> bool`;;

overload_interface' ("final",`SND:num list # bool -> bool`);;

liz_add {
liz_name = "final_face";
liz_loc =  (tamefile "Graph.thy",47,49);  (* see also lines 260,263 *)
liz_holl = `SND`;
liz_thm = final_SND;
};;

make_overloadable' "type" `:A -> bool`;;

overload_interface' ("type",`SND:num list # bool -> bool`);;

liz_add {
liz_name = "type_face";
liz_loc =  (tamefile "Graph.thy",50,52);  
liz_holl = `SND`;
liz_thm = type_face_SND;
};;

make_overloadable' "vertices" `:B -> (num list)`;;

overload_interface' ("vertices",`FST:num list # bool -> num list`);;

liz_add {
liz_name = "vertices_face";
liz_loc =  (tamefile "Graph.thy",53,55);  
liz_holl = `FST:num list # bool -> num list`;
liz_thm = vertices_face_FST;
};;

(*
let vertices_face = new_definition' `vertices_face (vs:A,f:B) = vs`;;
*)

make_overloadable' "__V" `:B -> (num -> bool)`;;

liz_add {
liz_name = "vertices_set";
liz_loc =  (tamefile "Graph.thy",24,26);  
liz_holl = `vertices_set`;
liz_thm = vertices_set;
};;

(* =~ on faces means =~ on vertex list *)

liz_add {
liz_name = "setFinal";
liz_loc =  (tamefile "Graph.thy",63,65);  
liz_holl = `setFinal`;
liz_thm = setFinal_ALT;
};;

(* !! incompletely specified *)

liz_add {
liz_name = "hd";
liz_loc =  (holfile "List.thy",26,28);  
liz_holl = `HD`;
liz_thm = HD;
};;

liz_add {
liz_name = "nextElem";
liz_loc =  (tamefile "Graph.thy",70,74);  
liz_holl = `nextElem`;
liz_thm = nextElem_ALT;
};;

(* XX nextVertex written as a dot . __bullet postfix *)

liz_add {
liz_name = "nextVertex";
liz_loc =  (tamefile "Graph.thy",75,77);  
liz_holl = `nextVertex`;
liz_thm = nextVertex_ALT;
};;

liz_add {
liz_name = "nextVertices";
liz_loc =  (tamefile "Graph.thy",82,84);  
liz_holl = `nextVertices`;
liz_thm = REWRITE_RULE[GSYM POWER_TO_ITER] nextVertices;
};;

(* op = REVERSE,  op_graph = Graph.op, op_graph *)

(* 4.3 Graphs *)

(*
graph:
list of faces (with boolean marking if each face is final),
number of vertices,
list whose ith entry is the list of faces containing vertex i,
a list of heights.

datatype graph = Graph "(face list)" "nat" "face list list" "nat list"
*)

liz_add {
liz_name = "Graph";
liz_loc =  (tamefile "Graph.thy",117,117);  
liz_holl = `Graph`;
liz_thm = GRAPH;
};;

(*
let new_graph_th = prove(`?(x:((num list # bool) list) #  (num) 
   # (((num list # bool) list) list) # (num list))  . T`,MESON_TAC[]);;

let graph_type = new_type_definition 
  "graph" ("mk_graph","dest_graph") new_graph_th;;
*)

liz_add {
liz_name = "faces";
liz_loc =  (tamefile "Graph.thy",119,121);  
liz_holl = `faces`;
liz_thm = faces_graph;
};;

liz_add {
liz_name = "Faces";
liz_loc =  (tamefile "Graph.thy",122,125);  
liz_holl = `Faces`;
liz_thm = FACES;
};;

liz_add {
liz_name = "countVertices";
liz_loc =  (tamefile "Graph.thy",126,128);  
liz_holl = `countVertices`;
liz_thm = countVertices;
};;

(* XX sypecial syntax *)

liz_add {
liz_name = "upt";
liz_loc =  (holfile "List.thy",153,155);  
liz_holl = `upt`;
liz_thm = upt_rec;
};;

overload_interface' ("vertices",`vertices_graph`);;

overload_interface' ("__V",`vertices_set2`);;

liz_add {
liz_name = "vertices_graph";
liz_loc =  (tamefile "Graph.thy",133,134);  
liz_holl = `vertices_graph`;
liz_thm = vertices_graph_alt;
};;

liz_add {
liz_name = "faceListAt";
liz_loc =  (tamefile "Graph.thy",148,150);  
liz_holl = `faceListAt`;
liz_thm = FACE_LIST_AT;
};;

liz_add {
liz_name = "facesAt";
liz_loc =  (tamefile "Graph.thy",151,153);  
liz_holl = `facesAt`;
liz_thm = REWRITE_RULE[GSYM C_EL] facesAt;
};;

liz_add {
liz_name = "heights";
liz_loc =  (tamefile "Graph.thy",154,156);  
liz_holl = `heights`;
liz_thm = HEIGHTS;
};;

liz_add {
liz_name = "height";
liz_loc =  (tamefile "Graph.thy",157,159);  
liz_holl = `height`;
liz_thm = REWRITE_RULE[GSYM C_EL] height;
};;

(* seed *)

liz_add {
liz_name = "replicate";
liz_loc =  (holfile "List.thy",197,199);  
liz_holl = `REPLICATE`;
liz_thm = REPLICATE;
};;

liz_add {
liz_name = "graph";
liz_loc =  (tamefile "Graph.thy",160,165);  
liz_holl = `graphl`;
liz_thm = graph_ALT;
};;

(* 4.4 Operations on graphs *)

(*
liz_add {
liz_name = "finals";
liz_loc =  (tamefile "Graph.thy",170,172);  
liz_holl = `finals`;
liz_thm = graph_ALT;
};;
*)

liz_add {
liz_name = "nonFinals";
liz_loc =  (tamefile "Graph.thy",173,175);  
liz_holl = `nonFinals`;
liz_thm = nonFinals;
};;

liz_add {
liz_name = "countNonFinals";
liz_loc =  (tamefile "Graph.thy",176,178);  
liz_holl = `countNonFinals`;
liz_thm = countNonFinals;
};;

override_interface' ("final",`finalGraph`);;

liz_add {
liz_name = "finalGraph";
liz_loc =  (tamefile "Graph.thy",179,180);  
liz_holl = `finalGraph`;
liz_thm = finalGraph;
};;


(*
let finalVertex = new_definition' `finalVertex g v = 
   (!f.  f IN set_of_list(facesAt g v) ==> SND f)`;;

liz_add {
liz_name = "finalVertex";
liz_loc =  (tamefile "Graph.thy",188,190);  
liz_holl = `finalVertex`;
liz_thm = finalVertex;
};;
*)

let degree = new_definition' `degree g v = LENGTH(facesAt g v)`;;

liz_add {
liz_name = "degree";
liz_loc =  (tamefile "Graph.thy",200,202);  
liz_holl = `degree`;
liz_thm = degree;
};;

let tri = new_definition'  `tri g v =
    LENGTH(FILTER (\f. SND f /\ LENGTH(vertices f)=3) (facesAt g v))`;;

liz_add {
liz_name = "tri";
liz_loc =  (tamefile "Graph.thy",203,205);   
liz_holl = `tri`;
liz_thm = tri;
};;

let quad = new_definition'  `quad g v =
    LENGTH(FILTER (\f. SND f /\ LENGTH(vertices f)=4) (facesAt g v))`;;

liz_add {
liz_name = "quad";
liz_loc =  (tamefile "Graph.thy",206,208);   
liz_holl = `quad`;
liz_thm = quad;
};;

let except = new_definition'  `except g v =
    LENGTH(FILTER (\f. SND f /\ 5 <= LENGTH(vertices f)) (facesAt g v))`;;

liz_add {
liz_name = "except";
liz_loc =  (tamefile "Graph.thy",209,211);   
liz_holl = `except`;
liz_thm = except;
};;

let vertextype = new_definition' `vertextype g v = 
    (tri g v, quad g v, except g v)`;;

liz_add {
liz_name = "vertextype";
liz_loc =  (tamefile "Graph.thy",212,214);   
liz_holl = `vertextype`;
liz_thm = vertextype;
};;

let exceptionalVertex = new_definition' `exceptionalVertex g v = 
  (except g v ~= 0)`;;

liz_add {
liz_name = "exceptionalVertex";
liz_loc =  (tamefile "Graph.thy",222,224);   
liz_holl = `exceptionalVertex`;
liz_thm = exceptionalVertex;
};;

liz_add {
liz_name = "neighbors";
liz_loc =  (tamefile "Graph.thy",235,237);   
liz_holl = `neighbors`;
liz_thm = neighbors;
};;

(* 4.5 Navigation in graphs *)

liz_add {
liz_name = "directedLength";
liz_loc =  (tamefile "Graph.thy",253,256);   
liz_holl = `directedLength`;
liz_thm = directedLength;
};;

(* 4.6 Code generator setup *)

(* 5 Vector *)

(* vector = list *)

(* 5.2 Access *)

liz_add {
liz_name = "sub1";
liz_loc =  (tamefile "Vector.thy",46,48);   
liz_holl = `sub1`;
liz_thm = sub1_ALT;
};;

liz_add {
liz_name = "sub";
liz_loc =  (tamefile "Vector.thy",49,51);   
liz_holl = `sub`;
liz_thm = sub;
};;

(* notaton: a[n] = sub a n, a[m,n] = sub (sub a m) n, a[l,m,n] = sub(sub(sub a l)m)n *)

(* 6 Enumerating Patches  *)


liz_add {
liz_name = "enumBase";
liz_loc =  (tamefile "Enumerator.thy",44,46);   
liz_holl = `enumBase`;
liz_thm = enumBase;
};;

liz_add {
liz_name = "enumAppend";
liz_loc =  (tamefile "Enumerator.thy",47,49);   
liz_holl = `enumAppend`;
liz_thm = enumAppend;
};;

liz_add {
liz_name = "enumerator";
liz_loc =  (tamefile "Enumerator.thy",50,54);   
liz_holl = `enumerator`;
liz_thm = enumerator;
};;

liz_add {
liz_name = "hideDupsRec";
liz_loc =  (tamefile "Enumerator.thy",65,70);   
liz_holl = `hideDupsRec`;
liz_thm = hideDupsRec;
};;

liz_add {
liz_name = "hideDups";
liz_loc =  (tamefile "Enumerator.thy",71,74);   
liz_holl = `hideDups`;
liz_thm = hideDups;
};;

liz_add {
liz_name = "indexToVertexList";
liz_loc =  (tamefile "Enumerator.thy",75,77);   
liz_holl = `indexToVertexList`;
liz_thm = indexToVertexList;
};;

(* 7 Subdividing a Face *)

liz_add {
liz_name = "split_face";
liz_loc =  (tamefile "FaceDivision.thy",10,16);   
liz_holl = `split_face`;
liz_thm = split_face;
};;

liz_add {
liz_name = "replacefacesAt";
liz_loc =  (tamefile "FaceDivision.thy",18,20);   
liz_holl = `replacefacesAt`;
liz_thm = replacefacesAt;
};;

liz_add {
liz_name = "makeFaceFinalFaceList";
liz_loc =  (tamefile "FaceDivision.thy",22,24);   
liz_holl = `makeFaceFinalFaceList`;
liz_thm = makeFaceFinalFaceList;
};;

liz_add {
liz_name = "makeFaceFinal";
liz_loc =  (tamefile "FaceDivision.thy",25,31);   
liz_holl = `makeFaceFinal`;
liz_thm = makeFaceFinal;
};;

liz_add {
liz_name = "heightsNewVertices";
liz_loc =  (tamefile "FaceDivision.thy",33,35);   
liz_holl = `heightsNewVertices`;
liz_thm = heightsNewVertices;
};;

liz_add {
liz_name = "splitFace";
liz_loc =  (tamefile "FaceDivision.thy",36,55);   
liz_holl = `splitFace`;
liz_thm = splitFace;
};;

liz_add {
liz_name = "subdivFace_";
liz_loc =  (tamefile "FaceDivision.thy",58,68);   
liz_holl = `subdivFace0`;
liz_thm = subdivFace0;
};;

liz_add {
liz_name = "subdivFace";
liz_loc =  (tamefile "FaceDivision.thy",69,71);   
liz_holl = `subdivFace`;
liz_thm = subdivFace;
};;

(* 8. Transitive closure *)

(* Library/rstc.ml already does the refl trans closure of a relation *)

(* notation: g  [s]->*   g'   for (g,g') IN (RTranCl' s)  *)

let RTranCl_ALT2 = prove_by_refinement(
  `!succs g g' g''.
    (g,g IN RTranCl succs) /\
     (g' IN set_of_list (succs g) /\
     g',g'' IN RTranCl succs
     ==> g,g'' IN RTranCl succs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[RTranCl;CURRY_DEF;UNCURRY_DEF;IN;RTC_REFL];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_RULES [`(\x y. MEM y (succs x))`];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  TYPIFY `g'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST;IN])
  ]);;
  (* }}} *)

liz_add {
liz_name = "RTranCl";
liz_loc =  (tamefile "RTranCl.thy",17,26);   
liz_holl = `RTranCl'`;
liz_thm = RTranCl_ALT2;
};;

liz_add {
liz_name = "maxGon";
liz_loc =  (tamefile "Plane.thy",11,13);   
liz_holl = `maxGon`;
liz_thm = maxGon;
};;

liz_add {
liz_name = "duplicateEdge";
liz_loc =  (tamefile "Plane.thy",17,20);   
liz_holl = `duplicateEdge`;
liz_thm = duplicateEdge;
};;

liz_add {
liz_name = "containsUnacceptableEdgeSnd";
liz_loc =  (tamefile "Plane.thy",21,28);   
liz_holl = `containsUnacceptableEdgeSnd`;
liz_thm = containsUnacceptableEdgeSnd;
};;

liz_add {
liz_name = "containsUnacceptableEdge";
liz_loc =  (tamefile "Plane.thy",29,35);   
liz_holl = `containsUnacceptableEdge`;
liz_thm = containsUnacceptableEdge;
};;

liz_add {
liz_name = "containsDuplicateEdge";
liz_loc =  (tamefile "Plane.thy",36,39);   
liz_holl = `containsDuplicateEdge`;
liz_thm = containsDuplicateEdge;
};;

liz_add {
liz_name = "generatePolygon";
liz_loc =  (tamefile "Plane.thy",49,55);   
liz_holl = `generatePolygon`;
liz_thm = generatePolygon;
};;

liz_add {
liz_name = "Seed";
liz_loc =  (tamefile "Plane.thy",62,64);   
liz_holl = `Seed`;
liz_thm = SEED;
};;

(* Plane1 *)

liz_add {
liz_name = "minimalFace";
liz_loc =  (tamefile "Plane1.thy",16,18);   
liz_holl = `minimalFace`;
liz_thm = minimalFace;
};;

liz_add {
liz_name = "minimalVertex";
liz_loc =  (tamefile "Plane1.thy",19,21);   
liz_holl = `minimalVertex`;
liz_thm = minimalVertex;
};;

liz_add {
liz_name = "next_plane";
liz_loc =  (tamefile "Plane1.thy",23,28);   
liz_holl = `next_plane`;
liz_thm = next_plane;
};;

override_interface' ("PlaneGraphs",`PlaneGraphsP`);;

liz_add {
liz_name = "PlaneGraphsP";
liz_loc =  (tamefile "Plane1.thy",29,31);   
liz_holl = `PlaneGraphsP`;
liz_thm = PlaneGraphsP;
};;

liz_add {
liz_name = "PlaneGraphs";
liz_loc =  (tamefile "Plane1.thy",32,34);   
liz_holl = `PlaneGraphs:((num)list#bool)list#num#(((num)list#bool)list)list#(num)list->bool`;
liz_thm = PlaneGraphs;
};;

remove_interface ("PlaneGraphs");;

(* 10 Properties 
   11 Properties of Patch Enumeration 
   12 Properties of Face Division
   13
   13.1, minVertex, normFace, normFaces, etc.
   16 Tameness *)

let squanderTarget = new_definition' `squanderTarget = 15410`;;

(* changed constants 2014/1/21 to allow
   real to num conversion of inequalities *)

let excessTCount = new_definition' `excessTCount = 6295`;; (* was 6300 *)

let squanderVertex = new_definition' `squanderVertex p q = 
  if (p=0 /\ q=3) then 6177 else
    if (p=0 /\ q=4) then 9696 else
      if (p=1 /\ q=2) then 6557 else
	if (p=1 /\ q=3) then 6176 else
	  if (p=2 /\ q=1) then 7967 else
	    if (p=2 /\ q=2) then 4116 else
	      if (p=2 /\ q=3) then 12846 else
		if (p=3 /\ q=1) then 3106 else
		  if (p=3 /\ q=2) then 8165 else
		    if (p=4 /\ q=0) then 3466 else
		      if (p=4 /\ q=1) then 3655 else
			if (p=5 /\ q=0) then 395 else
			  if (p=5 /\ q=1) then 11354 else
			    if (p=6 /\ q=0) then 6854 else
			      if (p=7 /\ q=0) then 14493 else squanderTarget`;;

(* Jul 2, 2014. Changed 2059 -> 2058, for compatibility with a lemma in Isabelle
   that requires squanderVertex p q >= q * squanderFace 4 *)

let squanderFace = new_definition' `squanderFace n = 
  if (n=3) then 0 else
    if (n=4) then 2058 else
      if (n=5) then 4819 else
	if (n=6) then 7120 else squanderTarget`;;

liz_add {
liz_name = "squanderTarget";
liz_loc =  (tamefile "Tame.thy",16,18);   
liz_holl = `squanderTarget`;
liz_thm = squanderTarget;
};;

liz_add {
liz_name = "excessTCount";
liz_loc =  (tamefile "Tame.thy",19,22);   
liz_holl = `excessTCount`;
liz_thm = excessTCount;
};;

liz_add {
liz_name = "squanderVertex";
liz_loc =  (tamefile "Tame.thy",23,41);   
liz_holl = `squanderVertex`;
liz_thm = squanderVertex;
};;

liz_add {
liz_name = "squanderFace";  (* __d *)
liz_loc =  (tamefile "Tame.thy",42,49);   
liz_holl = `squanderFace`;
liz_thm = squanderFace;
};;

(* 16.3 Admissible weight assignments *)

liz_add {
liz_name = "foldr";
liz_loc =  (holfile "List.thy",79,82);   
liz_holl = `foldr2`;
liz_thm = foldr2_ALT;
};;

liz_add {
liz_name = "listsum";
liz_loc =  (holfile "List.thy",91,93);   
liz_holl = `sumn`;
liz_thm = sumn_ALT;
};;

let admissible1 = new_definition' `admissible1 w g =
  (!f. f IN __F g ==> __d (LENGTH (vertices (f:num list # bool))) <= w f)`;;

let admissible2 = new_definition'  `admissible2 w g = 
  (!v. v IN __V g ==> (except g v = 0) ==> 
     squanderVertex (tri g v) (quad g v) <= sumn (MAP (\ f. w f) (facesAt g v)))`;;

let triangle = new_definition' `triangle (f:num list # bool) = (LENGTH (vertices f) = 3)`;;

let admissible3 = new_definition' `admissible3 w g = 
  (!v. (v IN __V g) ==> (vertextype g v = (5,0,1)) ==>
     (sumn (map (\ f. w f) (FILTER triangle (facesAt g v))) >= __a))`;;

let admissible' = new_definition' `admissible' w g = 
  (admissible1 w g /\ 
  admissible2 w g /\ admissible3 w g) `;;

liz_add {
liz_name = "admissible1";
liz_loc =  (tamefile "Tame.thy",95,97);   
liz_holl = `admissible1`;
liz_thm = admissible1;
};;

liz_add {
liz_name = "admissible2";
liz_loc =  (tamefile "Tame.thy",98,101);   
liz_holl = `admissible2`;
liz_thm = admissible2;
};;

liz_add {
liz_name = "triangle";
liz_loc =  (tamefile "Graph.thy",110,113);   
liz_holl = `triangle`;
liz_thm = triangle;
};;

liz_add {
liz_name = "admissible3";
liz_loc =  (tamefile "Tame.thy",102,105);   
liz_holl = `admissible3`;
liz_thm = admissible3;
};;

liz_add {
liz_name = "admissible";
liz_loc =  (tamefile "Tame.thy",110,112);   
liz_holl = `admissible'`;
liz_thm = admissible';
};;

(* 16.4 Tameness *)

let tame9a = new_definition' `tame9a g = 
  (!f. (f IN __F g) ==> 
     3 <= LENGTH(vertices f) /\ LENGTH(vertices (f:num list # bool)) <= 6)`;;

let tame10 = new_definition' `tame10 g = 
  (let n = countVertices g in
     13 <= n /\ n <= 15)`;;

let tame11a = new_definition'  `tame11a g = 
  (!v. (v IN __V g) ==>  3 <= degree g v)`;;

let tame11b = new_definition'  `tame11b g = 
  (!v. v IN __V g ==> 
     degree g v <= (if (except g v = 0) then 7 else 6))`;;

let tame12o = new_definition' `tame12o g = 
  (!v. v IN __V g ==>
     (except g v ~= 0 /\ degree g v = 6) ==> (vertextype g v = (5,0,1)))`;;

let tame13a = new_definition' `tame13a g = 
  (?w. admissible' w g /\ sumn (MAP (\ f. w f) (faces g)) < squanderTarget)`;;

let tame = new_definition' `tame g = 
  (tame9a g /\ tame10 g/\ tame11a g/\ 
    tame11b g/\ tame12o g/\ tame13a g)`;;

liz_add {
liz_name = "tame9a";
liz_loc =  (tamefile "Tame.thy",115,117);   
liz_holl = `tame9a`;
liz_thm = tame9a;
};;

liz_add {
liz_name = "tame10";
liz_loc =  (tamefile "Tame.thy",118,120);   
liz_holl = `tame10`;
liz_thm = tame10;
};;

liz_add {
liz_name = "tame11a";
liz_loc =  (tamefile "Tame.thy",124,126);   
liz_holl = `tame11a`;
liz_thm = tame11a;
};;

liz_add {
liz_name = "tame11b";
liz_loc =  (tamefile "Tame.thy",127,129);   
liz_holl = `tame11b`;
liz_thm = tame11b;
};;

liz_add {
liz_name = "tame12o";
liz_loc =  (tamefile "Tame.thy",130,133);   
liz_holl = `tame12o`;
liz_thm = tame12o;
};;

liz_add {
liz_name = "tame13a";
liz_loc =  (tamefile "Tame.thy",137,139);   
liz_holl = `tame13a`;
liz_thm = tame13a;
};;

liz_add {
liz_name = "tame";
liz_loc =  (tamefile "Tame.thy",142,144);   
liz_holl = `tame`;
liz_thm = tame;
};;

(* 26 *)

liz_add {
liz_name = "fgraph";
liz_loc =  (tamefile "ArchCompAux.thy",20,22);   
liz_holl = `fgraph`;
liz_thm = fgraph;
};;

(* the list Archive is the concatenation of Tri, Quad, Pent, and Hex.
    These definitions need to be loaded from the Arch theory (which converts
    them from .ML files)  
  tame_archive_lists is defined in good_list_archive.hl.
*)

(* completeness *)

let archive = new_definition' `archive = set_of_list tame_archive_lists`;;

(* XX need to check compatibility of lists.  Update Isabelle lists. *)

liz_add {
liz_name = "Archive";
liz_loc =  (tamefile "Completeness.thy",9,11);   
liz_holl = `archive`;
liz_thm = archive;
};;

(* See PlaneGraphIso.thy 891++, and Quasi_order.thy for notation in Completeness.thy:completeness *)

let EQ_CLASS = new_definition' ` ( //// ) A f = IMAGE (f:A->B) A`;;

parse_as_infix' ("////", (14, "right"));;

let IMAGE_INFIX = new_definition' `(  #?# ) f X = IMAGE (f:A->B) X`;;

parse_as_infix' ("#?#",(16,"right"));;

let is_pr_Hom = new_definition' `is_pr_Hom (phi:A->B) Fs1 Fs2 =
  ((( (MAP phi) #?# Fs1) //// (__cong)) = (Fs2 //// (__cong)))`;;

(* REWRITE_RULE[IMAGE_INFIX;EQ_CLASS] is_pr_Hom;; *)

let is_pr_Iso = new_definition' `is_pr_Iso (phi:A->B) Fs1 Fs2 = 
 (is_pr_Hom phi Fs1 Fs2 /\ inj_on phi (UNIONS (IMAGE (\ f. set_of_list f) Fs1  )))`;;

let is_Iso = new_definition' `is_Iso (phi:A->B) Fs1 Fs2 = 
 (is_pr_Iso phi Fs1 Fs2 \/ is_pr_Iso phi Fs1 (REVERSE #?# Fs2))`;;

let is_iso = new_definition' `is_iso (phi:A->B) Fs1 Fs2 = 
  is_Iso phi (set_of_list Fs1) (set_of_list Fs2)`;;

let iso_fgraph = new_definition' `iso_fgraph g1 g2 = 
  (? (phi:A->B). is_iso phi g1 g2)`;;

liz_add {
liz_name = "is_pr_Hom";
liz_loc =  (tamefile "PlaneGraphIso.thy",148,150);   
liz_holl = `is_pr_Hom`;
liz_thm = is_pr_Hom;
};;

liz_add {
liz_name = "is_pr_Iso";
liz_loc =  (tamefile "PlaneGraphIso.thy",151,153);   
liz_holl = `is_pr_Iso`;
liz_thm = is_pr_Iso;
};;

liz_add {
liz_name = "is_Iso";
liz_loc =  (tamefile "PlaneGraphIso.thy",815,817);   
liz_holl = `is_Iso`;
liz_thm = is_Iso;
};;

liz_add {
liz_name = "is_iso";
liz_loc =  (tamefile "PlaneGraphIso.thy",818,820);   
liz_holl = `is_iso`;
liz_thm = is_iso;
};;

liz_add {
liz_name = "iso_fgraph";
liz_loc =  (tamefile "PlaneGraphIso.thy",821,823);   
liz_holl = `iso_fgraph`;
liz_thm = iso_fgraph;
};;

(* (tamefile "Completeness.thy",48,49) *)

(* ?? __simeq = iso_fgraph??. Replace 2013-10-6 *)

let import_tame_classification = new_definition' 
  `import_tame_classification = 
  (!g. PlaneGraphs g /\ tame g ==> (?y. y IN archive /\ iso_fgraph (fgraph g) y))`;;

parse_as_infix ("IN_simeq", (11, "right"));;

let IN_SIMEQ = new_definition'
  `!A (x:((A)list)list). 
  x IN_simeq A <=> (?(y:((B)list)list). y IN A /\ iso_fgraph x y)`;;

let import_tame_classification_alt = prove_by_refinement(
  `import_tame_classification <=> 
  (!g. g IN PlaneGraphs /\ tame g ==> fgraph g IN_simeq archive)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[import_tame_classification;IN_SIMEQ;IN])
  ]);;
  (* }}} *)


(*
report_tame_def "iso_fgraph" 4;;
report_def HOLDIR "*" "list_sum" 5;;
*)

end;;
