<html><head><title>taylorFunction Documentation</title></head>
<body><h1>
<a name="topofdoc"><img src="diag2min.gif">taylorFunction</a></h1>
<dl>
<dd>
	A function that when evaluated yields a <a href="taylorInterval.html">taylorInterval</a>, that
	is it can be evaluated to give an explicit linear approximation
	with <a href="error.html">error</a> bounds.


</dl>
<hr><p></p>
<p><strong>[ 
<a href="kepler.html">kepler</a> | 
<a href="taylorInterval.h">Source</a> | 
<a href="keyweb.html">Keywords</a> | 
<a href="#aag">Summary</a> | <a href="#parents">Ancestors</a> | <a href="#flat">All Members</a> | <a href="#children">Descendants</a>  ]</strong><p>
<h2><a name="quickind">Quick Index</a></h2>
<dl>
<dd><a href="#OVERVIEW_TEXT">OVERVIEW TEXT</a>
<dd><a href="#AUTHOR">AUTHOR</a>
</dl>
<a name="aag"><hr><p></p></a><h2>Class Summary</h2>
class taylorFunction<br>
<br>
 {
<br>
<br><i><b>public</b></i>:
<dl>
<dd>taylorFunction <a href="taylorFunction.html#taylorFunction_operator+(const_taylorFunction&amp)_const$">operator+</a>(const taylorFunction&amp) const;
<dd>taylorFunction <a href="taylorFunction.html#taylorFunction_operator*(const_interval&amp)_const$">operator*</a>(const <a href="interval.html">interval</a>&amp) const;
<dd><a href="taylorFunction.html#taylorFunction(int_capacity_)$">taylorFunction</a>(int capacity );
<dd><a href="taylorFunction.html#taylorFunction(primitive&amp)$">taylorFunction</a>(primitive&amp);
<dd><a href="taylorFunction.html#taylorFunction(const_taylorFunction&amp)$">taylorFunction</a>(const taylorFunction&amp);
<dd>taylorFunction&amp <a href="taylorFunction.html#taylorFunction&amp_operator$(const_taylorFunction&amp_f)$">operator=</a>(const taylorFunction&amp f);
<dd>~<a href="taylorFunction.html#~taylorFunction()$">taylorFunction</a>();
<dd><a href="taylorInterval.html">taylorInterval</a> <a href="taylorFunction.html#taylorInterval_evalf(const_domain&amp_x,const_domain&amp_z)_const$">evalf</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z) const;
<dd><a href="lineInterval.html">lineInterval</a> <a href="taylorFunction.html#lineInterval_evalAt(const_domain&amp)_const$">evalAt</a>(const <a href="domain.html">domain</a>&amp) const;
<dd>int <a href="taylorFunction.html#int_getReducibleState()_const$">getReducibleState</a>() const;
<dd>void <a href="taylorFunction.html#void_setReducibleState(int)$">setReducibleState</a>(int);
<dd><strong>static</strong> void <a href="taylorFunction.html#void_selfTest()$">selfTest</a>();
</dl>
<i><b>protected</b></i>:
<dl>
</dl>
}; // taylorFunction <p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>taylorFunction</i><p>
<a name="OVERVIEW_TEXT"><hr><p></p></a><h3>OVERVIEW TEXT</h3>
<p>
	Taylor functions are the most important class in the the Kepler
	package in many ways.   They should be thought of as a rigorously
	implemented math library function.  To evaluate a function is
	to supply it with bounds on the lower and upper bounds on each
	of the variables, and an approximate center point where the
	taylor series approximation is to be computed.  
<p>
	When evaluated, instead of
	returning a mere double, a taylorFunction returns a <a href="taylorInterval.html">taylorInterval</a>,
	which constains information about the upper and lower bounds of
	the function on the given <a href="domain.html">domain</a>, and also about the upper and
	lower bounds of the derivatives of the function on the given <a href="domain.html">domain</a>.
<p>
	Taylor functions can be added together and multiplied by scalars.
	To get an upper bound on the sum of two taylorFunctions it is
	better to add them and then evaluate the sum, rather than evaluate
	the individual functions and then add the results.  The reason
	for this is that there can be cancellation of terms, so that
	the bound by adding first is, roughly speaking |x-x|, rather than |x|+|-x|.
<p>
<p>Back to the <a href="#topofdoc">top</a> of  <i>taylorFunction</i><p>
<a name="AUTHOR"><hr><p></p></a><h3>AUTHOR</h3>
<p>
	Thomas C. Hales
<p>Back to the <a href="#topofdoc">top</a> of  <i>taylorFunction</i><p>
<a name="taylorFunction_operator+(const_taylorFunction&amp)_const$"><hr><p></p><h3>taylorFunction operator+(const taylorFunction&amp) const;</h3></a>
	   Add a taylorFunctions to a given one.
<p>
<p><pre>
taylorFunction operator+(const taylorFunction&amp) const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="taylorFunction_operator*(const_interval&amp)_const$"><hr><p></p><h3>taylorFunction operator*(const interval&amp) const;</h3></a>
	   Scale a taylorFunction by a <a href="interval.html">interval</a> multiple.
<p>
<p><pre>
taylorFunction operator*(const <a href="interval.html">interval</a>&amp) const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="taylorFunction(int_capacity_)$"><hr><p></p><h3>taylorFunction(int capacity );</h3></a>
	   Constructor.  For advanced users: 
	   the capacity refers to the number of distinct
	   primitive functions occuring in the linear combination represented
	   by the taylorFunction.  If in doubt, 
	   use the default argument!
<p>
<p><pre>
<a href="#taylorFunction(const_taylorFunction&amp)$">taylorFunction</a>(int capacity =0);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="taylorFunction(primitive&amp)$"><hr><p></p><h3>taylorFunction(primitive&amp);</h3></a>
	   taylorFunctions are built up from certain primitive functions.
	   This is the constructor that converts a primitive function to
	   a taylorFunction.
	   The class primitive and this class is only used in the implementation
	   details.  End-users can safely ignore this constructor.
<p>
<p><pre>
<a href="#taylorFunction(const_taylorFunction&amp)$">taylorFunction</a>(primitive&amp);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="taylorFunction(const_taylorFunction&amp)$"><hr><p></p><h3>taylorFunction(const taylorFunction&amp);</h3></a>
	   create a bitwise copy of a taylorFunction
<p>
<p><pre>
<a href="#taylorFunction(const_taylorFunction&amp)$">taylorFunction</a>(const taylorFunction&amp);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="taylorFunction&amp_operator$(const_taylorFunction&amp_f)$"><hr><p></p><h3>taylorFunction&amp operator=(const taylorFunction&amp f);</h3></a>
	   assignment of a taylorFunction
<p>
<p><pre>
taylorFunction&amp operator=(const taylorFunction&amp f);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="~taylorFunction()$"><hr><p></p><h3>~taylorFunction();</h3></a>
	   Deallocate memory:
<p>
<p><pre>
~taylorFunction();
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="taylorInterval_evalf(const_domain&amp_x,const_domain&amp_z)_const$"><hr><p></p><h3>taylorInterval evalf(const domain&amp x,const domain&amp z) const;</h3></a>
	   Evaluate a taylorFunction
	   There are two arguments, x = lower bounds on variables,
	   z = upper bounds on variables,
<p>
<p><pre>
<a href="taylorInterval.html">taylorInterval</a> <a href="#taylorInterval_evalf(const_domain&amp_x,const_domain&amp_z)_const$">evalf</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z) const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="lineInterval_evalAt(const_domain&amp)_const$"><hr><p></p><h3>lineInterval evalAt(const domain&amp) const;</h3></a>
	   Evaluate a taylorFunction at a single point x
<p>
<p><pre>
<a href="lineInterval.html">lineInterval</a> <a href="#lineInterval_evalAt(const_domain&amp)_const$">evalAt</a>(const <a href="domain.html">domain</a>&amp) const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="int_getReducibleState()_const$"><hr><p></p><h3>int getReducibleState() const;</h3></a>
<p>
<p><pre>
int <a href="#int_getReducibleState()_const$">getReducibleState</a>() const;
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="void_setReducibleState(int)$"><hr><p></p><h3>void setReducibleState(int);</h3></a>
<p>
<p><pre>
void <a href="#void_setReducibleState(int)$">setReducibleState</a>(int);
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="void_selfTest()$"><hr><p></p><h3>void selfTest();</h3></a>
	   Check the correctness of Taylor routines.
<p>
<p><pre>
static void <a href="#void_selfTest()$">selfTest</a>();
</pre>
<br><p>Back to the <a href="#topofdoc">top</a> of  <i> taylorFunction </i> <p>
<a name="flat"><hr><p></p></a>
<h2>All Members</h2>
<dl>
<dt><strong>public:</strong>
<dd>taylorFunction <a href="taylorFunction.html#taylorFunction_operator+(const_taylorFunction&amp)_const$">operator+</a>(const taylorFunction&amp) const;
<dd>taylorFunction <a href="taylorFunction.html#taylorFunction_operator*(const_interval&amp)_const$">operator*</a>(const <a href="interval.html">interval</a>&amp) const;
<dd>taylorFunction&amp <a href="taylorFunction.html#taylorFunction&amp_operator$(const_taylorFunction&amp_f)$">operator=</a>(const taylorFunction&amp f);
<dd><a href="taylorInterval.html">taylorInterval</a> <a href="taylorFunction.html#taylorInterval_evalf(const_domain&amp_x,const_domain&amp_z)_const$">evalf</a>(const <a href="domain.html">domain</a>&amp x,const <a href="domain.html">domain</a>&amp z) const;
<dd><a href="lineInterval.html">lineInterval</a> <a href="taylorFunction.html#lineInterval_evalAt(const_domain&amp)_const$">evalAt</a>(const <a href="domain.html">domain</a>&amp) const;
<dd>int <a href="taylorFunction.html#int_getReducibleState()_const$">getReducibleState</a>() const;
<dd>void <a href="taylorFunction.html#void_setReducibleState(int)$">setReducibleState</a>(int);
<dd><strong>static</strong> void <a href="taylorFunction.html#void_selfTest()$">selfTest</a>();
<dt><strong>protected:</strong>
</dl>
<p>Back to the <a href="#topofdoc">top</a> of  taylorFunction<p>
<a name="parents"><hr><p></p></a>
<h2>Ancestors</h2>
Class does not inherit from any other class.<p>
<p>Back to the <a href="#topofdoc">top</a> of  taylorFunction<p>
<a name="children"><hr><p></p></a>
<h2>Descendants</h2>
Class is not inherited by any others.<p>
<p>Back to the <a href="#topofdoc">top</a> of  taylorFunction<p>
<hr><p></p>
Generated from source by the <i><a href="http://www.cs.umn.edu/~kotula/cocoon/cocoon.htm">Cocoon</a></i> utilities on Mon Dec 22 19:37:26 1997
.<p>
<address>Report <a href="mailto:jkotula@unimax.com">problems</a> to jkotula@unimax.com</address>
</body></html>
