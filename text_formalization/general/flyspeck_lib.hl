(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* HOL LIGHT pervasives                                                       *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2012-04-15                                                           *)
(* ========================================================================== *)


(* This file contains Ocaml library functions *)

(* Load `eval_command` *)
(* Example: eval_command ~silent:false "g `x=y`";; *)
(* Note: eval_command is not used by any formalization files *)
needs (String.concat "/" ["general"; if version_ge_4_14 then "flyspeck_eval_4.14.hl" else "flyspeck_eval.hl"]);;

module Flyspeck_lib = struct

include Flyspeck_eval;;

(* process_to_string in strictbuild.hl *)
let version() = "ver-0000";;


(* duplicated code *)

let rec nub = function 
  | [] -> []
  | x::xs -> x::filter ((<>) x) (nub xs);;

(* duplicated code *)

(* System commands *)

let output_filestring tmpfile a = 
  let outs = open_out tmpfile in
  let _ = try (Printf.fprintf outs "%s" a) 
  with _ as t -> (close_out outs; raise t) in
   close_out outs ;;

(* from glpk_link.ml *)

let load_and_close_channel do_close ic = 
  let rec lf ichan a = 
    try
      lf ic (Stdlib.input_line ic::a)
    with End_of_file -> a in
    let rs = lf ic [] in
      if do_close then Stdlib.close_in ic else ();
      rev rs;;

let load_and_close_channel_true ic = 
  let rec lf ichan a = 
    try
      lf ic (Stdlib.input_line ic::a)
    with End_of_file -> a | _ as t -> (Stdlib.close_in ic; raise t) in
    let rs = lf ic [] in
    let _ = Stdlib.close_in ic in
      rev rs;;

let load_file filename = 
  let ic = Stdlib.open_in filename in load_and_close_channel_true ic;;

let exists_pgm s = 
  let com = "command -v " ^ s in 
    not(process_to_string com = "");;


(* numerical *)

let dest_decimal x = match strip_comb x with
    | (dec,[a;b]) ->                     
	div_num (dest_numeral a) (dest_numeral b)
    | _ -> failwith ("dest_decimal: '" ^ string_of_term x ^ "'") ;;

let string_of_num' x = string_of_float (float_of_num x);; 


end;;
